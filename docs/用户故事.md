这是一个非常棒的技术选型调整。引入 **LangChain/LangGraph** 是解决你描述的“复杂上下文”、“多意图识别”以及“结构化数据处理”的完美方案。LangGraph 的**状态机（State Machine）**模式特别适合这种需要维护“简历当前状态（JSON）”并根据用户对话不断迭代的场景。

同时，使用本地 Python 模块解析 PDF 可以极大保护隐私并降低延迟。

以下是为你重新优化的、结合了 **LangGraph Agent** 架构的完整用户故事（User Stories）和功能规格。

---

### 核心架构概念：

* **前端 (React)**：渲染器（Renderer）。它不直接操作 HTML 字符串，而是将一个标准的 **JSON Schema** 渲染为界面。
* **后端 (FastAPI + LangGraph)**：状态管理器（State Manager）。AI 不只是“聊天”，而是在维护一个全局的 `ResumeState`，通过 Graph 的节点流转来修改这个 State。

请注意!所有模块都需要使用2025年12月25日,已知的最新内容,模块用法需要遵循官方文档,而不是猜测.

---

### 模块一：基础设施与系统配置 (Infrastructure & Config)

1. **[安全/鉴权] 无账号超级管理员**
* **作为管理员**，我希望通过服务器环境变量（如 `ADMIN_SECRET_KEY`）配置一个超级密码。
* **作为用户**，我希望在登录页输入该密码即可进入系统，无需注册流程，数据存储在本地 SQLite 中，单机部署简单快捷。


2. **[设置] 自定义 LLM 网关**
* **作为用户**，我希望在前端配置页填写 OpenAI 兼容的 `Base URL`、`API Key` 和 `Model Name`（如 gpt-4o, deepseek-coder）。
* **作为系统**，我希望后端使用 LangChain 的 `ChatOpenAI` 接口动态加载这些配置，以便我随时切换更聪明的模型来处理复杂的逻辑，或切换更快的模型来处理简单的润色。



---

### 模块二：文档解析与数据清洗 (Ingestion & Parsing)

*技术核心：本地 Python 库 (pdfplumber/pymupdf)*

3. **[解析] 本地 PDF/Docx 解析**
* **作为用户**，我希望上传现有的 PDF 或 Word 简历文档。
* **作为系统**，我希望使用 Python 原生库（如 `pdfplumber` 处理 PDF，`python-docx` 处理 Word）在本地服务器提取文本和基础布局信息，**不调用任何外部解析 API**，确保数据不出域。


4. **[数据] 非结构化转结构化 (ETL)**
* **作为系统（LangGraph Node）**，我希望定义一个 `ExtractionNode`，它接收解析后的纯文本，并使用 LLM 将其转化为符合系统标准的 **JSON 简历数据结构**（包含个人信息、教育经历 List、项目经历 List 等字段）。



---

### 模块三：LangGraph 智能体核心 (The Agent Brain)

*这是整个系统的大脑，负责路由、记忆和工具调用*

5. **[交互] 意图识别路由 (Router)**
* **作为系统**，我希望 LangGraph 有一个 `RouterNode`，能够分析用户的对话意图。
* 如果是“把字体改大点”、“左边加个栏”，路由到 -> **UI 修改代理 (Layout Agent)**。
* 如果是“帮我润色这段经历”、“翻译成英文”，路由到 -> **内容优化代理 (Content Agent)**。




6. **[编辑] UI 差异感知与最小化 Token (Diff Awareness)**
* **作为 Layout Agent**，当需要修改界面时，我希望只接收当前简历的 **JSON Schema** 结构，而不是巨大的 HTML 字符串。
* **作为开发者**，我希望 Agent 输出的是 **JSON Patch** (如 `{"op": "replace", "path": "/experience/0/title", "value": "Senior Eng"}`)，前端根据 Patch 更新状态。这能将 Token 消耗降低 80% 以上，并极大提升响应速度。


7. **[内容] 智能简历润色**
* **作为 Content Agent**，我希望内置一套经过打磨的提示词（Prompt Template），根据 STAR 法则（Situation, Task, Action, Result）自动重写用户简陋的项目描述。


8. **[记忆] 检查点与状态回滚 (Checkpointer)**
* **作为用户**，如果 AI 改坏了，我希望说“撤销刚才的操作”，系统能利用 LangGraph 的 `Checkpointer` 功能，回滚到上一个 `GraphState` 状态。



---

### 模块四：智能模板引擎与编辑器 (Visual Editor)

9. **[创建] 对话式模板生成**
* **作为用户**，我希望告诉 AI：“我要一个极简风格、左右分栏、蓝色主调的模板”。
* **作为系统**，AI 不直接写 CSS，而是生成一份 **Layout Configuration**（布局配置 JSON），前端 React 组件根据这份配置动态渲染布局。


10. **[操作] 混合编辑模式 (Hybrid Editing)**
* **作为用户**，我既可以在右侧聊天框指挥 AI 修改，也可以在左侧预览区直接点击文字进行编辑，或者拖拽改变区块顺序。
* **作为系统**，前端的手动修改操作需要同步回后端的 LangGraph State，确保 AI 下一轮对话时知道用户刚刚手动改了什么。



---

### 模块五：交付与历史 (Delivery)

11. **[导出] 高保真 PDF 导出**
* **作为用户**，我希望点击导出时，系统能将当前的 React DOM 完美转换为 PDF。
* **技术方案**：建议使用 `Puppeteer` (Python pyppeteer 或 Node 服务) 进行后端截图打印，或者前端使用 `window.print()` 的 CSS `@media print` 深度适配，确保 A4 纸分页不截断文字。


12. **[历史] 简历版本管理**
* **作为用户**，我希望能看到历史生成的简历列表，点击即可加载当时的 JSON 状态进行继续编辑。



---

### 推荐的数据结构 (Simplified)

为了配合 LangGraph 和 Token 优化，你的数据结构应该像这样：

```json
// ResumeState (在 LangGraph 中流转的核心对象)
{
  "messages": [...], // LangChain 消息历史
  "current_resume_data": { // 结构化数据
    "profile": { "name": "...", "email": "..." },
    "sections": [
      { "id": "exp-1", "type": "experience", "content": "..." },
      { "id": "proj-1", "type": "project", "content": "..." }
    ]
  },
  "layout_config": { // 样式数据
    "theme": "modern-blue",
    "column_layout": "two-column-3-7",
    "font_size": "14px"
  },
  "ui_context": { // 当前用户鼠标聚焦在哪里，用于局部更新
    "focused_section_id": "exp-1"
  }
}

```

### 推荐的 Python 库清单

* **Web 框架**: `FastAPI`, `Uvicorn`
* **数据库**: `Tortoise-ORM`, `aiosqlite`
* **AI 编排**: `langchain`, `langgraph` (必须使用最新版以支持 Graph), `langchain-openai`
* **PDF 解析**: `pdfplumber` (文字提取准确), `pymupdf` (速度快)
* **数据校验**: `Pydantic` (FastAPI 和 LangChain 的基石)


### 外部文档参考 

 - langgraph : https://docs.langchain.com/oss/python/langgraph/overview
 - pdfplumber : https://github.com/jsvine/pdfplumber